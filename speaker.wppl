var speechCost = 0
var pointCost = 70
var successValue = 100

var invLogit = function(x) {
  return Math.exp(x) / (1+Math.exp(x))
}

var knowProb = function(exposure) {
  return invLogit(-.4252 + 1.1487*Math.log2(exposure))
}


var exposure = 1

var actions = ['speak', 'point'];



var utility = function(outcome) {
  var table = { 
    point_success: successValue - pointCost, 
    speak_success: successValue - speechCost,
    failure: 0,
  };
  return table[outcome];
};

var learning = function(known, prob) {
  // model that takes 0/1 knowledge and updates based on trials, based on some parameter P
  var probLearned = flip(prob)
  // no forgetting, so only update prob if unknown
  if(known==true) {return true;} else {return probLearned;}
  //return known
}

var trials= ['wug','toma','toma','dax','dax','dax','dax',
             'fep','blicket','blicket','kreeb','kreeb','kreeb','kreeb',
             'gazzer','kiv','kiv','manu','manu','manu','manu',]


var initializeVocab = function(emptyArray) {
  var wordList = ["blicket", "kreeb", "wug", "fep", 
                          "toma", "dax", "gazzer", "kiv","manu"]
  map(function(element) {
     var newWord = {
       label: element,
       exposures: 0,
       known: 0
     };
     emptyArray.push(newWord)
  }, wordList)
  return emptyArray
}


var training = function(trialArray, vocabulary, learnProb) {

  var vocabSlice = vocabulary.splice()

  if (vocabSlice.length == 0) {
    initializeVocab(vocabSlice)
  }

  map(function(currentOne) {
    var vocabIndex = map(function(e) {return e.label;}, vocabSlice).indexOf(currentOne)
      var wordToUpdate = vocabSlice[vocabIndex] 

      var updatedWord =  { 
        label: wordToUpdate.label,
        exposures: wordToUpdate.exposures+1, 
        known: learning(wordToUpdate.known, learnProb) 
      }

      vocabSlice.splice(vocabIndex, 1, updatedWord)  
  }, trialArray)

  return vocabSlice 
}



var sameVocabulary = function(myVocab, yourVocab) {
  var differences = []
  map2(function(x, y) {
    // return x.known != y.known
    if (x.known != y.known) {
      differences.push('notSame')
    } 
  }, 
  myVocab,
  yourVocab)    
  return differences.length==0
}

var estimateLearnProb = function(vocabulary) {
  var parameter = sample(Beta({a:.5,b:.5}));

  var learnSample = training(trials, [], parameter);

  condition(sameVocabulary(vocabulary, learnSample))
  return parameter;
}

// use training() to infer what distribution over Ps (see factor() and logistic regression examples)
var simulate = function(trialArray) {
  // rough
  // return expectation(Infer({ 
  //  model() {
  //    return training(trialArray));
  //  }
  //}));    
}

var selectReferent = function(modality, referent, vocabulary) {
  if(modality =='point') return 'point_success';
  else {
    //get all known items from vocab
    var known_words = filter(function(x) {x.known}, vocabulary)
    //check if referent known in vocab
    if(filter(function(x) {return x.label == referent}, known_words).length >= 1)
      return 'speak_success';
    else {
      var guess_prob = 1/(vocabulary.length - known_words.length);     
      return categorical([guess_prob, 1-guess_prob], ['speak_success', 'failure']);
     }
  }
}

var sampleSpeaker = function(vocabulary, target) {
  return Infer({ 
    model() {

      var action = uniformDraw(actions);
      
      var expectedUtility = function(action) {
        return expectation(Infer({ 
          model() {
            return utility(selectReferent(action, target, vocabulary));
          }
        }));
      };
      
      factor(Math.log(expectedUtility(action)));
      
      return action;
    }
  });
};


// repeat(10, function() {training(trials,[], .3)})
var myLearning = training(trials,[], .45)

// myLearning
// estimateLearnProb(myLearning)

//myLearning

//utility(selectReferent("point", "wug", myLearning))


//Infer({method: 'rejection', samples: 500}, function() {estimateLearnProb(myLearning)})
//repeat(1, function() {sampleSpeaker(myLearning, "wug")})

sampleSpeaker(myLearning, "wug")

//training(trials, [])
//repeat(3, function() {training(trials, [], .45)})
//repeat(1, function() {learning(0, 1)})

//(repeat(100, function() { sample(sampleSpeaker())}))
//repeat(10,speakerProduces)