var speechCost = 0
var pointCost = 70
var successValue = 100

var invLogit = function(x) {
  return Math.exp(x) / (1+Math.exp(x))
}

var knowProb = function(exposure) {
  return invLogit(-.4252 + 1.1487*Math.log2(exposure))
}


var exposure = 1

var actions = ["speak", "point"];



var utility = function(outcome) {
  var table = { 
    point_success: successValue - pointCost, 
    speak_success: successValue - speechCost,
    failure: 0,
  };
  return table[outcome];
};





var learnProb = function(times, prob) {
  Binomial({p:prob, n:times}).score(0)
  // log(1-exp(Binomial({p:prob, n:times}).score(0)))
}

// learnProb(4,.45)



var learning = function(known, prob) {
  // model that takes 0/1 knowledge and updates based on trials, based on some parameter P
  var probLearned = flip(prob)

  // no forgetting, so only update prob if unknown
  if(known==true) {return true;} else {return probLearned;}
  //return known
}


var initializeVocab = function(emptyArray) {
  var wordList = ["blicket", "kreeb", "wug", "fep", 
                          "toma", "dax", "gazzer", "kiv","manu"]
  map(function(element) {
     var newWord = {
      label: element,
      exposures: 0,
      known: false
     };
     emptyArray.push(newWord)
  }, wordList)
  return emptyArray
}

var wordFromVocab = function(word, vocabulary) {
  var vocabIndex = _.findIndex(vocabulary, {label: word});
  return vocabulary[vocabIndex];
}


var training = function(trialArray, vocabulary, learnProb) {

  var vocabSlice = vocabulary.slice()

  if (vocabSlice.length == 0) {
    initializeVocab(vocabSlice)
  }

  map(function(trial) {
    var vocabIndex = _.findIndex(vocabSlice, {label: trial});
    var wordToUpdate = vocabSlice[vocabIndex];

    var updatedWord =  { 
      label: wordToUpdate.label,
      exposures: wordToUpdate.exposures+1, 
      known: learning(wordToUpdate.known, learnProb) 
    }

    vocabSlice.splice(vocabIndex, 1, updatedWord);

  }, trialArray)


  return vocabSlice;
}




var possibleVocabs = function(trialArray, learnProbDist) {
  return Infer({method: "rejection", samples:100, 
    model() {
      var sampleP = sample(learnProbDist);
      var oneVocab = training(trialArray, [], sampleP) ;
      return oneVocab;
    }
  });
};

var conditionVocabs = function(vocabDist, word) {
  return Infer({method: "rejection", samples:100, 
    model() {
      var sampleVocab = sample(vocabDist)
      var targetIndex = _.findIndex(sampleVocab, {label: word})

      condition(sampleVocab[targetIndex].known)

      return sampleVocab
    }
  })
}




var sameVocabulary = function(myVocab, yourVocab) {
  var differences = []
  map2(function(x, y) {
    // return x.known != y.known
    if (x.known != y.known) {
      differences.push("notSame")
    } 
  }, 
  myVocab,
  yourVocab)    
  return differences.length==0
}

var estimateLearnProb = function(vocabulary, trainingTrials) {
  //Infer({ method: 'rejection', samples: 10,
  Infer({  
    model(){
      var parameter = sample(Beta({a:.5,b:.5}));
      var learnSample = training(trainingTrials, [], parameter);
      observe(training(trainingTrials, [], parameter), vocabulary)
      //condition(sameVocabulary(vocabulary, learnSample));
      return parameter
    }
  })
}



var selectReferent = function(modality, referent, speakerVocab, receiverVocab) {
  if(modality =="point") return "point_success";

  else {
    //get all known items from receiverVocab
    var speakerKnows = filter(function(x) {return x.label == referent}, speakerVocab).length >= 1

    if(!speakerKnows)
      return "failure"
    else {
      var receiverKnows = filter(function(x) {x.known}, receiverVocab)
      //check if referent known in vocab

      if(filter(function(x) {return x.label == referent}, receiverKnows).length >= 1)
        return "speak_success";
      else {
        //var guess_prob = 1/(receiverVocab.length - receiverKnows.length);     
        var guess_prob = 0;
        //var guess_prob = 1/receiverVocab.length
        return categorical([guess_prob, 1-guess_prob], ["speak_success", "failure"]);
      }
    }
  }
}

var sampleSpeaker = function(speakerVocab, receiverVocab, target) {
  return Infer({ 
    model() {

      var action = uniformDraw(actions);
      
      var expectedUtility = function(action) {
        return expectation(Infer({ 
          model() {
            return utility(selectReferent(action, target, speakerVocab, receiverVocab));
          }
        }));
      };
      
      factor(Math.log(expectedUtility(action)));
      
      return action
    }
  });
};


var unknownReceiver = function(target, myVocab) {
  var receiverVocab = training(trials, [], .45);

  return sample(sampleSpeaker(myVocab, receiverVocab, target));
}

var unknownBoth = function(target) {
  var myVocab = training(trials, [], .45)
  var receiverVocab = training(trials, [], .45);

  return sample(sampleSpeaker(myVocab, receiverVocab, target));
}


var constructTrials = function(empiricalVocab) {
  var empiricalSlice = empiricalVocab.slice()
    var trials = map(function(element){
      var arrayToAdd= []
      repeat(element.exposures, function() {arrayToAdd.push(element.label)})
      return arrayToAdd
    }, empiricalSlice)
    return trials.join().split(',')
}


// var trials = ["wug","toma","toma","dax","dax","dax","dax",
//              "fep","blicket","blicket","kreeb","kreeb","kreeb","kreeb",
//              "gazzer","kiv","kiv","manu","manu","manu","manu"]
 // empiricalTrials[0].realLabel


var ldfs = _.uniq(
  map(function(element) {
    return element.ldf_num
  }, empiricalVocabs)
)
var ldfs_test = filter(function(subID) {return subID < 3}, ldfs)
// ldfs_test
// _.filter(ldfs, function(subID) {return subID < 100})
// ldfs_test

map( function(x) {
  var myVocab = _.filter(empiricalVocabs, {ldf_num : x})
  var myTrials= constructTrials(myVocab)
  var learnPs = estimateLearnProb(myVocab, myTrials)
  return learnPs
}, ldfs_test)

// var myVocab = _.filter(empiricalVocabs, {ldf_num : 1})
// var myVocab = empiricalVocabs
// myVocab
// var myTrials = constructTrials(myVocab)
 // myTrials
// var myVocab = training(trials,[], .3)
// myVocab
// var learnP = estimateLearnProb(myVocab, myTrials)
// learnP


// var possibleVocabs= estimateLearnProb2(myVocab, trials)
// observeVocab(myVocab, possibleVocabs)

// updatePossibleVocabs('wug', true)
//sampleSpeaker(myLearning, "wug")



//repeat(1000, function() {unknownBoth("wug")})


// var hypotheticalVocabs = possibleVocabs(myTrials, learnP)
// hypotheticalVocabs
// conditionVocabs(hypotheticalVocabs, "fep")

// updatingPossibleVocabs(possibleVocabs(trials,.5), 'wug', false)

//training(trials, [])
//repeat(3, function() {training(trials, [], .45)})
//repeat(1, function() {learning(0, 1)})

//(repeat(100, function() { sample(sampleSpeaker())}))
//repeat(10,speakerProduces)