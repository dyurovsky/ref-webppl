var speechCost = 0
var pointCost = 70
var successValue = 100

var actions = ["speak", "point"];

var utility = function(outcome) {
  var table = { 
    point_success: successValue - pointCost, 
    speak_success: successValue - speechCost,
    failure: 0,
  };
  return table[outcome];
};

var unknownProb = function(times, prob) {
  Binomial({p:prob, n:times}).score(0)
}

var knownProb = function(times, prob) {
  Math.log(1-Math.exp(unknownProb(times, prob)))
}

var vocabProb = function(vocabulary, prob) {
  var totalProb = map(function(word) {
    word.known ? knownProb(word.exposures, prob) :
     unknownProb(word.exposures, prob)}, vocabulary)

  return sum(totalProb)
} 


// var learning = function(known, prob) {
//   // model that takes 0/1 knowledge and updates based on trials, based on some parameter P
//   var probLearned = flip(prob)

//   // no forgetting, so only update prob if unknown
//   if(known==true) {return true;} else {return probLearned;}
//   //return known
// }


// var initializeVocab = function(emptyArray) {
//   var wordList = ["blicket", "kreeb", "wug", "fep", 
//                           "toma", "dax", "gazzer", "kiv","manu"]
//   map(function(element) {
//      var newWord = {
//       label: element,
//       exposures: 0,
//       known: false
//      };
//      emptyArray.push(newWord)
//   }, wordList)
//   return emptyArray
// }

var wordFromVocab = function(word, vocabulary) {
  var vocabIndex = _.findIndex(vocabulary, {label: word});
  return vocabulary[vocabIndex];
}


var training = function(trials, learnProb) {

  map(function(trial) {
    var isknown = sample(Bernoulli({p: learnProb, n:trial.exposures}))

    return {label: trial.label, exposures: trial.exposures, known: isknown}
  }, trials) 

}

var wordList = ["blicket", "kreeb", "wug", "fep", 
                        "toma", "dax", "gazzer", "kiv","manu"];

var freqList = [4, 4, 4, 2, 2, 2, 1, 1, 1];

var trainingTrials = map2(function(word, freq) { return {label: word, exposures: freq} }, wordList, freqList)

// var possibleVocabs = function(trialArray, learnProbDist) {
//   return Infer({method: "rejection", samples:100, 
//     model() {
//       var sampleP = sample(learnProbDist);
//       var oneVocab = training(trialArray, [], sampleP) ;
//       return oneVocab;
//     }
//   });
// };

// var conditionVocabs = function(vocabDist, word) {
//   return Infer({method: "rejection", samples:100, 
//     model() {
//       var sampleVocab = sample(vocabDist)
//       var targetIndex = _.findIndex(sampleVocab, {label: word})

//       condition(sampleVocab[targetIndex].known)

//       return sampleVocab
//     }
//   })
// }

// var sameVocabulary = function(myVocab, yourVocab) {
//   var differences = []
//   map2(function(x, y) {
//     // return x.known != y.known
//     if (x.known != y.known) {
//       differences.push("notSame")
//     } 
//   }, 
//   myVocab,
//   yourVocab)    
//   return differences.length==0
// }

var estimateLearnProb = function(vocabulary) {
  Infer({ method: 'MCMC', samples: 10000, burn:2000,
  //Infer({  
    model() {
      var parameter = sample(Beta({a:.5,b:.5}));
      factor(vocabProb(vocabulary, parameter))

      //condition(sameVocabulary(vocabulary, learnSample));
      return parameter;
    }
  })
}

//var myVocab = training(trainingTrials, .45)
//estimateLearnProb(myVocab)

var selectReferent = function(modality, referent, speakerVocab, receiverVocab) {
  if(modality =="point") return "point_success";

  else {
    //get all known items from receiverVocab
    var speakerKnows = filter(function(x) {return x.label == referent}, speakerVocab).length >= 1

    if(!speakerKnows)
      return "failure"
    else {
      var receiverKnows = filter(function(x) {x.known}, receiverVocab)
      //check if referent known in vocab

      if(filter(function(x) {return x.label == referent}, receiverKnows).length >= 1)
        return "speak_success";
      else {
        //var guess_prob = 1/(receiverVocab.length - receiverKnows.length);     
        var guess_prob = 0;
        //var guess_prob = 1/receiverVocab.length
        return categorical([guess_prob, 1-guess_prob], ["speak_success", "failure"]);
      }
    }
  }
}

var sampleSpeaker = function(speakerVocab, receiverVocab, target) {
  return Infer({ 
    model() {

      var action = uniformDraw(actions);
      
      var expectedUtility = function(action) {
        return expectation(Infer({ 
          model() {
            return utility(selectReferent(action, target, speakerVocab, receiverVocab));
          }
        }));
      };
      
      factor(Math.log(expectedUtility(action)));
      
      return action
    }
  });
};


var unknownReceiver = function(target, myVocab) {
  var estimatedLearnProb = expectation(estimateLearnProb(myVocab));

  var receiverVocab = training(trials, estimatedLearnProb);

  return sample(sampleSpeaker(myVocab, receiverVocab, target));
}

var ldfs = _.uniq(
  map(function(element) {
    return element.ldf_num
  }, empiricalVocabs)
)

var ldfs_test = filter(function(subID) {return subID < 4}, ldfs)


map( function(x) {
  var myVocab = _.filter(empiricalVocabs, {ldf_num : x})
  var learnPs = estimateLearnProb(myVocab)
  return expectation(learnPs)

}, ldfs_test)

// // var myVocab = _.filter(empiricalVocabs, {ldf_num : 1})
// // var myVocab = empiricalVocabs
// // myVocab
// // var myTrials = constructTrials(myVocab)
//  // myTrials

// //var myVocab = training(trials,[], .45)

// //map2(function(time, prob) {knownProb(time, prob)}, [1, 2, 3, 4], [.5, .5, .5, .5])

// //var learnP = estimateLearnProb(myVocab)
// //learnP

// // var possibleVocabs= estimateLearnProb2(myVocab, trials)
// // observeVocab(myVocab, possibleVocabs)

// // updatePossibleVocabs('wug', true)
// //sampleSpeaker(myLearning, "wug")
