var speechCost = 0
var pointCost = 70
var successValue = 100

var invLogit = function(x) {
  return Math.exp(x) / (1+Math.exp(x))
}

var knowProb = function(exposure) {
  return invLogit(-.4252 + 1.1487*Math.log2(exposure))
}


var exposure = 1

var actions = ["speak", "point"];



var utility = function(outcome) {
  var table = { 
    point_success: successValue - pointCost, 
    speak_success: successValue - speechCost,
    failure: 0,
  };
  return table[outcome];
};

var learning = function(known, prob) {
  // model that takes 0/1 knowledge and updates based on trials, based on some parameter P
  var probLearned = flip(prob)
  // no forgetting, so only update prob if unknown
  if(known==true) {return true;} else {return probLearned;}
  //return known
}

var trials = ["wug","toma","toma","dax","dax","dax","dax",
             "fep","blicket","blicket","kreeb","kreeb","kreeb","kreeb",
             "gazzer","kiv","kiv","manu","manu","manu","manu"]

var initializeVocab = function(emptyArray) {
  var wordList = ["blicket", "kreeb", "wug", "fep", 
                          "toma", "dax", "gazzer", "kiv","manu"]
  map(function(element) {
     var newWord = {
       label: element,
       exposures: 0,
       known: false
     };
     emptyArray.push(newWord)
  }, wordList)
  return emptyArray
}


var training = function(trialArray, vocabulary, learnProb) {

  var vocabSplice = vocabulary.splice()

  if (vocabSplice.length == 0) {
    initializeVocab(vocabSplice)
  }

  return trainOneWord(0, vocabSplice, learnProb);
}

var trainOneWord = function(trial, vocabulary, learnProb) {

  if(trials.length == trial)
    return vocabulary;

  var thisTrial = trials[trial]

  var vocabIndex = map(function(e) {return e.label;}, vocabulary).indexOf(thisTrial);
  var wordToUpdate = vocabulary[vocabIndex];

  var updatedWord =  { 
    label: wordToUpdate.label,
    exposures: wordToUpdate.exposures+1, 
    known: learning(wordToUpdate.known, learnProb) 
  }

  vocabulary.splice(vocabIndex, 1, updatedWord);

  return trainOneWord(trial+1, vocabulary, learnProb);

}


var possibleVocabs = function(trialArray, learnProb) {
  return Infer({method: "rejection", samples:10000, 
    model() {
      return training(trialArray, [], learnProb) ;
  }});
};

var sameVocabulary = function(myVocab, yourVocab) {
  var differences = []
  map2(function(x, y) {
    // return x.known != y.known
    if (x.known != y.known) {
      differences.push("notSame")
    } 
  }, 
  myVocab,
  yourVocab)    
  return differences.length==0
}

var estimateLearnProb = function(vocabulary) {
  var parameter = sample(Beta({a:.5,b:.5}));

  var learnSample = training(trials, [], parameter);

  condition(sameVocabulary(vocabulary, learnSample))
  return parameter;
}


var selectReferent = function(modality, referent, speakerVocab, receiverVocab) {
  if(modality =="point") return "point_success";

  else {
    //get all known items from receiverVocab
    var speakerKnows = filter(function(x) {return x.label == referent}, speakerVocab).length >= 1

    if(!speakerKnows)
      return "failure"
    else {
      var receiverKnows = filter(function(x) {x.known}, receiverVocab)
      //check if referent known in vocab

      if(filter(function(x) {return x.label == referent}, receiverKnows).length >= 1)
        return "speak_success";
      else {
        //var guess_prob = 1/(receiverVocab.length - receiverKnows.length);     
        var guess_prob = 0;
        //var guess_prob = 1/receiverVocab.length
        return categorical([guess_prob, 1-guess_prob], ["speak_success", "failure"]);
      }
    }
  }
}

var sampleSpeaker = function(speakerVocab, receiverVocab, target) {
  return Infer({ 
    model() {

      var action = uniformDraw(actions);
      
      var expectedUtility = function(action) {
        return expectation(Infer({ 
          model() {
            return utility(selectReferent(action, target, speakerVocab, receiverVocab));
          }
        }));
      };
      
      factor(Math.log(expectedUtility(action)));
      
      return action
    }
  });
};


var unknownReceiver = function(target, myVocab) {
  var receiverVocab = training(trials, [], .45);

  return sample(sampleSpeaker(myVocab, receiverVocab, target));
}

var unknownBoth = function(target) {

  var myVocab = training(trials, [], .45)
  var receiverVocab = training(trials, [], .45);

  return sample(sampleSpeaker(myVocab, receiverVocab, target));
}


//sampleSpeaker(myLearning, "wug")



//repeat(1000, function() {unknownBoth("wug")})

possibleVocabs(trials, .45)

//training(trials, [])
//repeat(3, function() {training(trials, [], .45)})
//repeat(1, function() {learning(0, 1)})

//(repeat(100, function() { sample(sampleSpeaker())}))
//repeat(10,speakerProduces)