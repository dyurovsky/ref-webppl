var speechCost = 0
var pointCost = 70
var successValue = 100

var actions = ["speak", "point"];

var utility = function(outcome) {
  var table = { 
    point_success: successValue - pointCost, 
    speak_success: successValue - speechCost,
    failure_speaker: 0,
    failure_receiver: 0,
  };
  return table[outcome];
};

var unknownProb = function(times, prob) {
  Binomial({p:prob, n:times}).score(0)
}

var knownProb = function(times, prob) {
  Math.log(1-Math.exp(unknownProb(times, prob)))
}

var vocabProb = function(vocabulary, prob) {
  var totalProb = map(function(word) {
    word.known ? knownProb(word.exposures, prob) :
     unknownProb(word.exposures, prob)}, vocabulary)

  return sum(totalProb)
} 



var initializeVocab = function(trials, learnProb) {
  var learnedArray = []

  map(function(element) {
     var newWord = {
      label: element.label,
      exposures: element.exposures,
      known: Math.exp(knownProb(element.exposures, learnProb))
     };
     learnedArray.push(newWord)
  }, trials)
  return learnedArray
}

var wordFromVocab = function(word, vocabulary) {
  var vocabIndex = _.findIndex(vocabulary, {label: word});
  return vocabulary[vocabIndex];
}


var training = function(trials, learnProb) {

  map(function(trial) {
    var isknown = sample(Bernoulli({p: learnProb, n:trial.exposures}))

    return {label: trial.label, exposures: trial.exposures, known: isknown}
  }, trials) 

}




var estimateLearnProb = function(vocabulary) {
  Infer({ method: 'MCMC', samples: 10000, burn:2000,
  //Infer({  
    model() {
      var parameter = sample(Beta({a:.5,b:.5}));
      factor(vocabProb(vocabulary, parameter))

      //condition(sameVocabulary(vocabulary, learnSample));
      return parameter;
    }
  })
}



var selectReferent = function(modality, referent, speakerVocab, receiverVocab) {
  if(modality == "point") return "point_success";

  else {
    //get all known items from receiverVocab
    var speakerKnows = filter(function(x) {return x.label == referent}, speakerVocab)[0].known

    if(!speakerKnows)
      return "failure_speaker"
    else {
      var receiverKnows = filter(function(x) {return x.label == referent}, receiverVocab)[0].known
      //check if referent known in vocab

      return(categorical([receiverKnows, 1-receiverKnows], ["speak_success", "failure_receiver"]));
    }
  }
}

var sampleSpeaker = function(speakerVocab, receiverVocab, target) {
  return Infer({ 
    model() {

      var action = uniformDraw(actions);
      
      var expectedUtility = function(action) {
        return expectation(Infer({ 
          model() {
            return utility(selectReferent(action, target, speakerVocab, receiverVocab));
          }
        }));
      };
      
      factor(Math.log(expectedUtility(action)));
      
      return action
    }
  });
};

var utilityRecursive = function(trials, target, action, speakerVocab, receiverVocab, U, updates, appearanceNumber) {
  var trialArray = trials.slice()
  var outcome1 = selectReferent(action, target, speakerVocab, receiverVocab)
  // var outcome1 = updates[appearanceNumber].outcome
  // var outcome1 = updates[0].outcome
  var utilityUpdated = utility(outcome1) + U
  var targetIndex= _.indexOf(trialArray, target)
  trialArray.splice(targetIndex, 1)
  
  if(_.indexOf(trialArray, target)>=0){
    var updatedReceiver = updateVocab(receiverVocab, target, outcome1)
    utilityRecursive(trialArray, target, action, speakerVocab, updatedReceiver, utilityUpdated, updates, appearanceNumber+1)
  } else {
    return  utilityUpdated
  }
};

var saveUpdates = function(speakerVocab, receiverVocab, action, target, newArray, optionalRepeats) {

  var newOutcome = selectReferent(action, target, speakerVocab, receiverVocab)
  var newVocab = updateVocab(receiverVocab, target, newOutcome)
  var newUpdate = {
    outcome: newOutcome,
    vocab: newVocab
  }
  newArray.push(newUpdate)

  if(optionalRepeats>1) {
    saveUpdates(speakerVocab, newVocab, action, target, newArray, optionalRepeats-1)
  } else {
    return newArray
  }
}


var sampleSpeakerPlanner = function(speakerVocab, receiverVocab, someTrials, index) {
  // var receiverVocab = receiverVocab.slice()
  return mapIndexed(function(index, element){

    // if(index < someTrials.length) {
      var restOfTrials = someTrials.slice(index)
      var element= restOfTrials[0]
      return Infer({ 
        model() {
          var action = uniformDraw(actions);
                          // var updates = saveUpdates(myVocab, yourVocab, 'speak', 'toma', [], 3)

          var updates = saveUpdates(speakerVocab, receiverVocab, action, element, [], 3)
          var expectedUtility = function(action) {
            return expectation(Infer({ 
              model() {
                return utilityRecursive(restOfTrials, element, action, speakerVocab, receiverVocab, 0, updates, 0);
              }
            }));
          };
          
          factor(Math.log(expectedUtility(action)));
          return action
        }
      });

    //   sampleSpeakerPlanner(speakerVocab, receiverVocab, someTrials, index+1)
    // } else {
    //   // return receiverVocab
    // }

  }, someTrials) 
};


var findWordandUpdate = function(word, vocab, changingKnownTo) {
  var vocabIndex = _.findIndex(vocab, {label: word});
  var newWord = {
    label: vocab[vocabIndex].label,
    exposures: vocab[vocabIndex].exposures,
    known: changingKnownTo
   };
  vocab.splice(vocabIndex, 1, newWord) 
  return vocab
}

var updateVocab = function(receiverVocab, referent, outcome) {
  var otherVocab=receiverVocab.slice()
  if(outcome=="speak_success") {
    findWordandUpdate(referent, otherVocab, 1)
  } 
  if(outcome=="failure_receiver") {
    findWordandUpdate(referent, otherVocab, 0)
  }
  // in all other cases, no need to alter because outcome is uninformative
  return otherVocab
}



var unknownReceiver = function(target, myVocab) {
  var estimatedLearnProb = expectation(estimateLearnProb(myVocab));

  var receiverVocab = training(trials, estimatedLearnProb);

  return sample(sampleSpeaker(myVocab, receiverVocab, target));
}



// -------------------------------------------------------
var wordList = ["blicket", "kreeb", "wug", "fep", 
                        "toma", "dax", "gazzer", "kiv","manu"];

var freqList = [4, 4, 4, 2, 2, 2, 1, 1, 1];

var trainingTrials = map2(function(word, freq) {return {label: word, exposures: freq} }, wordList, freqList)

var gameTrials = ["blicket","blicket","blicket", "kreeb","kreeb","kreeb", "wug","wug","wug", "fep","fep","fep", 
                        "toma","toma","toma", "dax","dax","dax", "gazzer","gazzer","gazzer", "kiv","kiv","kiv",
                        "manu","manu","manu"]



var ldfs = _.uniq(
  map(function(element) {
    return element.ldf_num
  }, empiricalVocabs)
)

var ldfs_test = filter(function(subID) {return subID < 5}, ldfs)

map(function(x) {
  var myVocab = _.filter(empiricalVocabs, {ldf_num : x})
  var learnPs = estimateLearnProb(myVocab)
  // return {learnPs}
  var estimatedProb = expectation(learnPs)
  var yourVocab = initializeVocab(myVocab, estimatedProb)
  var vocabProb = map(function(element) {(sampleSpeaker(myVocab, yourVocab, element.label))},
      myVocab)
  // return vocabProb
  // var tmp = (sampleSpeaker(myVocab, yourVocab, 'wug'))
  // return {tmp}

  // return utilityRecursive(gameTrials, 'toma', 'speak', myVocab, yourVocab, 0, saveUpdates(myVocab, yourVocab, 'speak', 'toma', [], 4), 0)
  // return repeat(10, function() {selectReferent('speak', 'toma',  myVocab, yourVocab)})

                // var updates = saveUpdates(myVocab, yourVocab, 'speak', 'toma', [], 3)
                // return updates[0].outcome

    sampleSpeakerPlanner(myVocab, yourVocab, gameTrials, 0);

// return  gameTrials.map(function(currentValue, index){return index})
   // return gameTrials.slice(_.indexOf(gameTrials, 'toma'))
  // map(function(element) {updateVocab(myVocab, yourVocab, element)}, wordList)
  // return yourVocab
    // var vocabProb = map(function(element) {(sampleSpeaker(myVocab, yourVocab, element.label))},
    //   myVocab)
    // return vocabProb

  // return repeat(3,function() {selectReferent("speak", "dax", myVocab, yourVocab)})
}, ldfs_test)


// // var myVocab = _.filter(empiricalVocabs, {ldf_num : 1})

